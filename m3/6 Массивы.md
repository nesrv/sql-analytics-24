
## Массивы

PostgreSQL позволяет создавать в таблицах такие столбцы, в которых будут содержаться не скалярные значения, а массивы переменной длины. 

Эти массивы могут быть многомерными и могут содержать значения любого из встроенных типов, а также типов данных, определенных пользователем.

```sql

SELECT ARRAY[111, 222, 333] as M;
SELECT ARRAY[ARRAY[111, 222, 333]] as M;
SELECT ARRAY[ARRAY['1', 2, '32'],
			ARRAY[5, 6, 7^2],
			ARRAY[8.4, 9e2, 0/5]
			] as M; 

```

Предположим, что нам необходимо сформировать и сохранить в базе данных в удобной форме графики работы пилотов авиакомпании, т. е. номера дней недели, когда они совершают полеты. 

Создадим таблицу, в которой эти графики будут храниться в виде единых списков, т. е. в виде одномерных массивов.

```sql

CREATE TABLE pilots
    (
    pilot_name text,
    schedule integer[]
    );
```


Для указания на то, что это массив, нужно добавить квадратные скобки к наименованию типа данных. 

При этом задавать число элементов не обязательно. Давайте добавим в таблицу четыре строки. 

Массив в команде вставки представлен в виде строкового литерала с указанием типа данных и квадратных скобок, означаю-
щих массив. 

Обратите внимание, что все массивы имеют различное число элементов.

```sql
INSERT INTO pilots
    VALUES ( 'Ivan', '{ 1, 3, 5, 6, 7 }'::integer[] ),
    ( 'Petr', '{ 1, 2, 5, 7 }'::integer[] ),
    ( 'Pavel', '{ 2, 5 }'::integer[] ),
    ( 'Boris', '{ 3, 5, 6 }'::integer[] );
```

Посмотрим, что получилось:
```sql
SELECT * FROM pilots;
```

```
pilot_name | schedule
------------+-------------
Ivan | {1,3,5,6,7}
Petr | {1,2,5,7}
Pavel | {2,5}
Boris | {3,5,6}
(4 строки)
```

Предположим, что руководство компании решило, что каждый пилот должен летать 4 раза в неделю. 

Значит, нам придется обновить значения в таблице. 

Пилоту по имени Boris добавим один день с помощью операции конкатенации:

```sql
UPDATE pilots
SET schedule = schedule || 7
WHERE pilot_name = 'Boris';
```


Пилоту по имени Pavel добавим один день в конец списка (массива) с помощью функции array_append:

```sql
UPDATE pilots
SET schedule = array_append( schedule, 6 )
WHERE pilot_name = 'Pavel';
```

Ему же добавим один день в начало списка с помощью функции array_ prepend (обратите внимание, что параметры функции поменялись местами):

```sql
UPDATE pilots
SET schedule = array_prepend( 1, schedule )
WHERE pilot_name = 'Pavel';
```


У пилота по имени Ivan имеется лишний день в графике. 

С помощью функции array_remove удалим из графика пятницу (второй параметр функции указывает значение элемента массива, а не индекс):
```sql
UPDATE pilots
SET schedule = array_remove( schedule, 5 )
WHERE pilot_name = 'Ivan';
```

У пилота по имени Petr изменим дни полетов, не изменяя их общего количества. 

Воспользуемся индексами для работы на уровне отдельных элементов массива. 

По умолчанию нумерация индексов начинается с единицы, а не с нуля. 

При необходимости ее можно изменить. 

К элементам одного и того же массива можно обращаться в предложении SET по отдельности, как будто это разные столбцы.

```sql
UPDATE pilots
SET schedule[ 1 ] = 2, schedule[ 2 ] = 3
WHERE pilot_name = 'Petr';
```

А можно было бы, используя срез `(slice)` массива, сделать и так:

```sql
UPDATE pilots
SET schedule[ 1:2 ] = ARRAY[ 2, 3 ]
WHERE pilot_name = 'Petr';
UPDATE 1
```

В вышеприведенной команде запись 1:2 означает индексы первого и последнего элементов диапазона массива. 
Нотация с использованием ключевого слова ARRAY — это альтернативный способ создания массива (он соответствует стандарту SQL). 

Таким образом, присваивание новых значений производится сразу целому диапазону элементов массива.
```sql
SELECT * FROM pilots;
```

```
pilot_name | schedule
------------+-----------
Boris | {3,5,6,7}
Pavel | {1,2,5,6}
Ivan | {1,3,6,7}
Petr | {2,3,5,7}
(4 строки)
```


Теперь продемонстрируем основные операции, которые можно применять к массивам, выполняя выборки из таблиц. 

Получим список пилотов, летающих по средам:

```sql
SELECT * FROM pilots
WHERE array_position( schedule, 3 ) IS NOT NULL;
```

```
pilot_name | schedule
------------+-----------
Boris | {3,5,6,7}
Ivan | {1,3,6,7}
Petr | {2,3,5,7}
(3 строки)
```

Функция array_position возвращает индекс первого вхождения элемента с указанным значением в массив. 
Если же такого элемента нет, она возвратит `NULL`. 

Выберем пилотов, летающих по понедельникам и воскресеньям:

```sql
SELECT * FROM pilots
WHERE schedule @> '{ 1, 7 }'::integer[];
```

```
pilot_name | schedule
------------+-----------
Ivan | {1,3,6,7}
(1 строка)
```

Оператор `@>` означает проверку того факта, что в левом массиве содержатся все элементы правого массива. 
Конечно, при этом в левом массиве могут находиться и другие элементы, что мы и видим в графике этого пилота.

Еще аналогичный вопрос: кто летает по вторникам и/или по пятницам? 

Для получения ответа воспользуемся оператором &&, который проверяет наличие общих элементов у массивов, т. е. пересекаются ли их множества значений. 

В нашем примере число общих элементов, если они есть, может быть равно одному или двум. 
Здесь мы использовали нотацию с ключевым словом `ARRAY`, а `не '{2, 5}'::integer[]`. 

Вы можете применять ту, которая принята в рамках выполнения вашего проекта.
```sql
SELECT * FROM pilots
WHERE schedule && ARRAY[ 2, 5 ];
```

```
pilot_name | schedule
------------+-----------
Boris | {3,5,6,7}
Pavel | {1,2,5,6}
Petr | {2,3,5,7}
(3 строки)
```


Сформулируем вопрос в форме отрицания: кто не летает ни во вторник, ни в пятницу? 

Для получения ответа добавим в предыдущую SQL-команду отрицание NOT:

```sql
SELECT * FROM pilots
WHERE NOT ( schedule && ARRAY[ 2, 5 ] );
```

```
pilot_name | schedule
------------+-----------
Ivan | {1,3,6,7}
(1 строка)
```

Иногда требуется развернуть массив в виде столбца таблицы. В таком случае поможет функция `unnest`:
```sql
SELECT unnest( schedule ) AS days_of_week
FROM pilots
WHERE pilot_name = 'Ivan';
```

```
days_of_week
--------------
1
3
6
7
(4 строки)
```


