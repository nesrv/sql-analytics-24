# Составные типы данных
## Массивы


Столбцы в таблице в `PostgreSQL` могут представлять массивы, например, массивы чисел INTEGER или массивы строк VARCHAR или массивы других типов данных. 

Рассмотрим, как работать с массивами в PostgreSQL.

Вначале определим простейшую таблицу:

```sql
create table posts(
    id serial primary key,
    title varchar(30),
    body text,
    tags varchar(10)[]
);
```

Таблица posts будет хранить условные статьи, где столбец `title` хранит заголовок статьи, `body` - ее текст, а `tags` - список тегов статьи. 

Причем столбец `tags` представляет массив данных `varchar(10)`, то есть строк. 

Для определения массива после названия типа указываются квадратные скобки.

Добавим в эту таблицу одну статью с набором тегов:

```sql
insert into posts(title, body, tags)
values('Post Title', 'Post Text', '{"sql", "postgres", "database", "plsql"}');
```

Массив определяется в кавычках, как и строка, но внутри кавычек все элементы массива помещаются в фигурные скобки. 

Каждый отдельный элемент массива заключается в двойные кавычки. 

То есть в данном случае в массиве четыре элемента: 

`"sql", "postgres", "database" и "plsql"`.

Как и данные любого другого столбца, мы можем извлечь данные массива:

```sql
select tags from posts;
```


Однако с помощью индексов мы также можем конкретизировать, какие именно элементы массива мы хотим получить:

```sql
select tags[0:3] from posts;
```

Индексы указываются в скобках через двоеточие. 

Вначале идет индекс начала диапазона, а затем индекс конца диапазона. 

То есть в данном случае извлекаем три тега с первого по третий.

При обновлении строки мы можем изменять как в целом все теги, так и какие-то конкретные теги. Например, удалим все теги:


```sql
update posts 
set tags='{}'
where id=1;
```

Переустановим массив:

```sql
update posts 
set tags='{"sql", "postgres", "database"}'
where id=1;

```
Переустановим конкретный элемент, например, второй:


```sql
update posts 
set tags[2]='system'
where id=1;
```

## Перечисления enum

`PostgreSQL` имеет специальный тип данных, который называется enum и который представляет набор констант. 

И столбец подобного типа может в качестве значения принимать одну из этих констант. 

Рассмотрим, как использовать перечисления.

Для создания перечисления используется команда `CREATE TYPE`. 

Например, создадим простейшее перечисление:

```sql
create type request_state as enum ('created', 'approved', 'finshed');
```

Данное перечисление называется `"request_state"`. 

После слова `enum` в скобках указывается через запятую список констант, которые составляют данное перечисление. 

То есть в данном случае перечисление `request_status` может принимать три значения: `'created', 'approved', 'finshed'`.

После создания перечисления мы можем использовать его в качестве типа столбца. 

Например, создадим следующую таблицу:

```sql
create table requests(
    id serial primary key,
    title varchar(30),
    status request_state
);
```

Здесь третий столбец - `status` представляет перечисление `request_state` и может принимать одно из трех выше указанных значений. 

Поэтому при добавлении данных нужно указать для данного столбца одно из этих трех значений:


```sql
insert into requests(title, status)
values ('Request 1', 'created');
```


При этом важно, что столбец может иметь только одно из этих трех значений, а не какие-то произвольные значения. 

Кроме того, большую роль играет регистр символов, например, `"created"` не эквивалентно `"Created"`.


При обновлении данных также необходиом предоставить одно из значений перечисления:

```sql
update requests 
set status='approved'
where id=1;
```

## Изменение перечисления

После создания перечисления вполне возможно нам захочется его изменить, например, добавить новое значение. 

Для этого применяется команда `ALTER TYPE`.

Добавление нового значения:

```sql
ALTER TYPE request_state ADD VALUE 'blocked';
```


К сожалению, удалить так просто уже имеющееся значение из перечисления не получится.

В этому случае мы можем создать новое перечисление и указать, чтобы таблица использовала именно новое перечисление:


```sql
CREATE TYPE status_enum AS ENUM('created', 'approved', 'done');
 
ALTER TABLE requests ALTER COLUMN status TYPE status_enum 
USING status::text::status_enum;
```

### Удаление


Если перечисление больше не нужно, то с помощью команды DROP TYPE его можно удалить:

```sql
DROP TYPE request_state;
```



## Явное объявление составного типа

```sql
CREATE TYPE currency AS (
amount numeric,
code text
);
```

`\dT`


Такой тип можно использовать точно так же, как любой другой тип SQL. Например, мы можем создать таблицу со
столбцами такого типа:

```sql
CREATE TABLE transactions(
account_id integer,
debit currency,
credit currency,
date_entered date DEFAULT current_date
);
```

Универсальных рецептов тут не существует. 

В определенных случаях это может быть полезно; в каких-то удобнее действовать в реляционных рамках: выделить сущность, представляемую типом, в отдельную таблицу и ссылаться на нее. 

Это позволить избежать избыточности данных (нормализация) и упростить индексирование (в случае составного типа скорее всего потребуется индекс по выражению).

В целом PostgreSQL обладает достаточно большим количеством встроенных типов данных, так что, вероятно,
необходимость в создании собственного типа будет возникать не часто, если не сказать редко.

## Конструирование значений составных типов

```sql
INSERT INTO transactions VALUES (1, NULL, '(100.00,"RUB")');


Другой способ — конструктор ROW:

```sql
INSERT INTO transactions VALUES (2, ROW(80.00,'RUB'), NULL);
```

Если составной тип содержит более одного поля, то слово ROW можно опустить:
```sql
INSERT INTO transactions VALUES (3, (20.00,'RUB'), NULL);


SELECT * FROM transactions;
```

## Атрибуты составного типа как отдельные значения

Обращение к отдельному атрибуту составного типа — по сути то же, что и обращению к столбцу таблицы, ведь
строка таблицы — это и есть составной тип:
```sql
SELECT t.account_id FROM transactions t
```

Как правило, требуется брать составное значение в скобки, например, чтобы отличать атрибут записи от столбца
таблицы:
```sql
SELECT (t.debit).amount, (t.credit).amount FROM transactions t;
```

```
amount | amount
--------+--------
| 100.00
80.00 |
20.00 |
(3 rows)
```

Или в случае, когда используется выражение:
```sql
SELECT ((10.00,'RUB')::currency).amount;
```
amount
--------
10.00
(1 row)


Составное значение не обязательно связано с каким-то конкретным типом, оно может быть неопределенной
записью псевдотипа record:
```sql
SELECT (10.00,'RUB')::record;
```
-------------
(10.00,RUB)
(1 row)

Но получится ли обратиться к атрибуту такой записи?
```sql
SELECT ((10.00,'RUB')::record).amount;
```

`ERROR: could not identify column "amount" in record data type
LINE 1: SELECT ((10.00,'RUB')::record).amount;
^
`
Нет, поскольку атрибуты такого типа безымянные.

## Неявный составной тип для таблиц

Более частое на практике применение составных типов — упрощение работы функций с таблицами.
При создании таблицы неявно создается и одноименный составной тип. 

Например, места в кинотеатре:

```sql
CREATE TABLE seats(
line text,
number integer
);

INSERT INTO seats VALUES
('A', 42), ('B', 1), ('C', 27);


Команда `\dT` «прячет» такие неявные типы, но при желании их можно увидеть непосредственно в таблице `pg_type`:

```sql
SELECT typtype FROM pg_type WHERE typname = 'seats';
```

### Операции над значениями составных типов

Значения составных типов можно сравнивать между собой. Это происходит поэлементно (примерно так же, как
строки сравниваются посимвольно):
```sql
SELECT * FROM seats s WHERE s < ('B',52)::seats;


line | number
------+--------
A | 42
B | 1
(2 rows)

```

Осторожно: существует много тонкостей, связанных с неопределенными значениями внутри записей.

Также работает проверка на неопределенность `IS [NOT] NULL` и сравнение `IS [NOT] DISTINCT FROM`.

Составные типы можно использовать с подзапросами, что бывает очень удобно.

Добавим таблицу с билетами:
```sql

CREATE TABLE tickets(
line text,
number integer,
movie_start date
);
CREATE TABLE

INSERT INTO tickets VALUES
('A', 42, current_date),
('B', 1, current_date+1);
```

Теперь, например, можно написать такой запрос для поиска мест в билетах на сегодняшний сеанс:
```sql
SELECT * FROM seats WHERE (line, number) IN (SELECT line, number FROM tickets WHERE movie_start = current_date
);


line | number
------+--------
A | 42
(1 row)
```

Без возможности использовать подзапрос пришлось бы явно соединять таблицы.