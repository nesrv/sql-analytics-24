## Типы JSON


Типы JSON предназначены для сохранения в столбцах таблиц базы данных таких значений, которые представлены в формате JSON (JavaScript Object Notation). 

Существует два типа: `json и jsonb`. 

Основное различие между ними заключается в быстродействии. 

Если столбец имеет тип json, тогда сохранение значений происходит быстрее, потому что они записываются в том виде, в котором были введены. 

Но при последующем использовании этих значений в качестве операндов или параметров функций будет каждый раз выполняться их разбор, что замедляет работу.

При использовании типа jsonb разбор производится однократно, при записи значения в таблицу. 

Это несколько замедляет операции вставки строк, в которых содержатся значения данного типа. 

Но все последующие обращения к сохраненным значениям выполняются быстрее, т. к. выполнять их разбор уже не требуется.

Есть еще ряд отличий, в частности, тип json сохраняет порядок следования ключей в объектах и повторяющиеся значения ключей, а тип jsonb этого не делает. 

Рекомендуется в приложениях использовать тип jsonb, если только нет каких-то особых аргументов в пользу выбора типа json.

Для иллюстрации использования типов JSON обратимся к тематике авиаперевозок. 

Предположим, что руководство авиакомпании всемерно поддерживает стремление пилотов улучшать свое здоровье, повышать уровень культуры и расширять кругозор.

Поэтому разработчики базы данных авиакомпании получили задание создать специальную таблицу, в которую будут заноситься сведения о тех видах спорта, которыми занимается пилот, будет отмечаться наличие у него домашней библиотеки, а также фиксироваться количество стран, которые он посетил в ходе туристических поездок.

```sql
CREATE TABLE pilot_hobbies
    (
    pilot_name text,
    hobbies jsonb
    );

CREATE TABLE

INSERT INTO pilot_hobbies
VALUES ( 'Ivan',
    '{ "sports": [ "футбол", "плавание" ],
        "home_lib": true, "trips": 3
    }'::jsonb
    ),
    ( 'Petr',
        '{ "sports": [ "теннис", "плавание" ],
    "home_lib": true, "trips": 2
    }'::jsonb
    ),
    ( 'Pavel',
        '{ "sports": [ "плавание" ],
    "home_lib": false, "trips": 4
    }'::jsonb
    ),
    ( 'Boris',
        '{ "sports": [ "футбол", "плавание", "теннис" ],
    "home_lib": true, "trips": 0
    }'::jsonb
    );
```


```sql
SELECT * FROM pilot_hobbies;
```


```
pilot_name | hobbies
------------+------------------------------------------------
Ivan | {"trips": 3, "sports": ["футбол", "плавание"],
"home_lib": true}
Petr | {"trips": 2, "sports": ["теннис", "плавание"],
"home_lib": true}
Pavel | {"trips": 4, "sports": ["плавание"],
"home_lib": false}
Boris | {"trips": 0, "sports": ["футбол", "плавание",
"теннис"], "home_lib": true}
(4 строки)
```

Как видно, при выводе строк из таблицы порядок ключей в `JSON-объектах` не был сохранен.

Предположим, что нужно сформировать футбольную сборную команду нашей авиакомпании для участия в турнире. 

Мы можем выбрать всех футболистов таким способом:

```sql
SELECT * FROM pilot_hobbies
WHERE hobbies @> '{ "sports": [ "футбол" ] }'::jsonb;
```
```
pilot_name | hobbies
------------+------------------------------------------------
Ivan | {"trips": 3, "sports": ["футбол", "плавание"],
"home_lib": true}
Boris | {"trips": 0, "sports": ["футбол", "плавание",
"теннис"], "home_lib": true}
(2 строки)
```


Можно было эту задачу решить и таким способом:

```sql
SELECT pilot_name, hobbies->'sports' AS sports
FROM pilot_hobbies
WHERE hobbies->'sports' @> '[ "футбол" ]'::jsonb;
```

```
pilot_name | sports
------------+----------------------------------
Ivan | ["футбол", "плавание"]
Boris | ["футбол", "плавание", "теннис"]
(2 строки)
```

В этом решении мы выводим только информацию о спортивных предпочтениях пилотов. 
Внимательно посмотрите, как используются одинарные и двойные кавычки. 

Операция -> служит для обращения к конкретному ключу JSON-объекта.

При создании столбца с типом данных json или jsonb не требуется задавать структуру объектов, т. е. конкретные имена ключей. Поэтому в принципе возможна ситуация, когда в разных строках в JSON-объектах будут использоваться различные наборы ключей.

В нашем примере структуры JSON-объектов во всех строках совпадают.

А если бы они не совпадали, то как можно было бы проверить наличие ключа?
Продемонстрируем это.

Ключа sport в наших объектах нет. Что покажет вызов функции count?

```sql
SELECT count( * )
FROM pilot_hobbies
WHERE hobbies ? 'sport';
```

```
count
-------
0
(1 строка)
```

А вот ключ `sports` присутствует. 

Выполним ту же проверку:

```sql
SELECT count( * )
FROM pilot_hobbies
WHERE hobbies ? 'sports';
```

Да, так и есть. Такие записи найдены.
```
count
-------
4
(1 строка)
```

А как выполнять обновление `JSON-объектов` в строках таблицы? 

Предположим, что пилот по имени Boris решил посвятить себя только хоккею.

Тогда в базе данных мы
выполним такую операцию:

```sql
UPDATE pilot_hobbies
SET hobbies = hobbies || '{ "sports": [ "хоккей" ] }'
WHERE pilot_name = 'Boris';
```

Проверим, что получилось:
```sql
SELECT pilot_name, hobbies
FROM pilot_hobbies
WHERE pilot_name = 'Boris';
```

```
pilot_name | hobbies
------------+------------------------------------------------------
Boris | {"trips": 0, "sports": ["хоккей"], "home_lib": true}
(1 строка)
```

Если впоследствии Boris захочет возобновить занятия футболом, то с помощью функции `jsonb_set` можно будет обновить сведения о нем в таблице:
```sql
UPDATE pilot_hobbies
SET hobbies = jsonb_set( hobbies, '{ sports, 1 }', '"футбол"' )
WHERE pilot_name = 'Boris';
```


Второй параметр функции указывает путь в пределах JSON-объекта, куда нужно добавить новое значение. 
В данном случае этот путь состоит из имени ключа (sports) и номера добавляемого элемента в массиве видов спорта (номер 1).
Нумерация элементов начинается с нуля. 

Третий параметр имеет тип `jsonb`, поэтому его литерал заключается в одинарные кавычки, а само добавляемое значение берется в двойные
кавычки. 

В результате получается — '"футбол"'.

Проверим успешность выполнения этой операции:
```sql
SELECT pilot_name, hobbies
FROM pilot_hobbies
WHERE pilot_name = 'Boris';
```

```
pilot_name | hobbies
------------+------------------------------------------------------
Boris | {"trips": 0, "sports": ["хоккей", "футбол"],
"home_lib": true}
(1 строка)
```