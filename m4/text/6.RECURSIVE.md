# Рекурсивные запросы в PostgreSQL

## Что такое рекурсия в SQL?

**Рекурсивный запрос** — это запрос, который ссылается сам на себя. В PostgreSQL используется конструкция `WITH RECURSIVE` для создания таких запросов.

### Структура рекурсивного запроса
```sql
WITH RECURSIVE имя_таблицы AS (
    -- Базовый случай (начальные данные)
    SELECT ...
    
    UNION ALL
    
    -- Рекурсивный случай (ссылка на саму себя)
    SELECT ... FROM имя_таблицы WHERE условие_остановки
)
SELECT * FROM имя_таблицы;
```

---

## Простые примеры для понимания

### Пример 1: Счет от 1 до 5
```sql
WITH RECURSIVE counter AS (
    -- Базовый случай: начинаем с 1
    SELECT 1 AS num
    
    UNION ALL
    
    -- Рекурсивный случай: добавляем 1
    SELECT num + 1 
    FROM counter 
    WHERE num < 5  -- условие остановки
)
SELECT * FROM counter;
```

**Результат:**
```
num
---
1
2
3
4
5
```

### Пример 2: Степени двойки
```sql
WITH RECURSIVE powers_of_two AS (
    -- Базовый случай: 2^0 = 1
    SELECT 0 AS power, 1 AS value
    
    UNION ALL
    
    -- Рекурсивный случай: следующая степень
    SELECT power + 1, value * 2
    FROM powers_of_two
    WHERE power < 10
)
SELECT power, value, power || '^2 = ' || value AS formula
FROM powers_of_two;
```

**Результат:**
```
power | value | formula
------|-------|--------
0     | 1     | 0^2 = 1
1     | 2     | 1^2 = 2
2     | 4     | 2^2 = 4
3     | 8     | 3^2 = 8
...
```

---

## Математические последовательности

### Факториал (n!)
```sql
WITH RECURSIVE factorial AS (
    -- Базовый случай: 1! = 1
    SELECT 1 AS n, 1::BIGINT AS fact
    
    UNION ALL
    
    -- Рекурсивный случай: n! = n * (n-1)!
    SELECT n + 1, fact * (n + 1)
    FROM factorial
    WHERE n < 10
)
SELECT 
    n,
    fact,
    n || '! = ' || fact AS formula
FROM factorial;
```

**Результат:**
```
n  | fact    | formula
---|---------|----------
1  | 1       | 1! = 1
2  | 2       | 2! = 2
3  | 6       | 3! = 6
4  | 24      | 4! = 24
5  | 120     | 5! = 120
...
10 | 3628800 | 10! = 3628800
```

### Числа Фибоначчи
```sql
WITH RECURSIVE fibonacci AS (
    -- Базовый случай: F(0)=0, F(1)=1
    SELECT 
        0 AS n,
        0::BIGINT AS fib_current,
        1::BIGINT AS fib_next
    
    UNION ALL
    
    -- Рекурсивный случай: F(n) = F(n-1) + F(n-2)
    SELECT 
        n + 1,
        fib_next,
        fib_current + fib_next
    FROM fibonacci
    WHERE n < 15
)
SELECT 
    n,
    fib_current AS fibonacci_number,
    'F(' || n || ') = ' || fib_current AS formula
FROM fibonacci;
```

**Результат:**
```
n  | fibonacci_number | formula
---|------------------|----------
0  | 0                | F(0) = 0
1  | 1                | F(1) = 1
2  | 1                | F(2) = 1
3  | 2                | F(3) = 2
4  | 3                | F(4) = 3
5  | 5                | F(5) = 5
8  | 21               | F(8) = 21
13 | 233              | F(13) = 233
```

---

## Работа с иерархическими данными

### Пример: Организационная структура
```sql
-- Создаем таблицу сотрудников
CREATE TABLE employees (
    id INTEGER PRIMARY KEY,
    name TEXT,
    manager_id INTEGER REFERENCES employees(id)
);

INSERT INTO employees VALUES
(1, 'Генеральный директор', NULL),
(2, 'Директор по продажам', 1),
(3, 'Директор по маркетингу', 1),
(4, 'Менеджер отдела А', 2),
(5, 'Менеджер отдела Б', 2),
(6, 'Продавец 1', 4),
(7, 'Продавец 2', 4),
(8, 'Маркетолог', 3);
```

### Получение всех подчиненных
```sql
WITH RECURSIVE subordinates AS (
    -- Базовый случай: начинаем с директора по продажам
    SELECT 
        id, 
        name, 
        manager_id,
        0 AS level,
        name AS path
    FROM employees 
    WHERE id = 2  -- Директор по продажам
    
    UNION ALL
    
    -- Рекурсивный случай: находим подчиненных
    SELECT 
        e.id,
        e.name,
        e.manager_id,
        s.level + 1,
        s.path || ' → ' || e.name
    FROM employees e
    JOIN subordinates s ON e.manager_id = s.id
)
SELECT 
    REPEAT('  ', level) || name AS hierarchy,
    level,
    path
FROM subordinates
ORDER BY level, name;
```

**Результат:**
```
hierarchy              | level | path
-----------------------|-------|---------------------------
Директор по продажам   | 0     | Директор по продажам
  Менеджер отдела А    | 1     | Директор по продажам → Менеджер отдела А
  Менеджер отдела Б    | 1     | Директор по продажам → Менеджер отдела Б
    Продавец 1         | 2     | Директор по продажам → Менеджер отдела А → Продавец 1
    Продавец 2         | 2     | Директор по продажам → Менеджер отдела А → Продавец 2
```

### Получение пути до корня
```sql
WITH RECURSIVE employee_path AS (
    -- Базовый случай: начинаем с конкретного сотрудника
    SELECT 
        id,
        name,
        manager_id,
        0 AS level,
        name AS path_to_root
    FROM employees
    WHERE id = 6  -- Продавец 1
    
    UNION ALL
    
    -- Рекурсивный случай: поднимаемся по иерархии
    SELECT 
        e.id,
        e.name,
        e.manager_id,
        ep.level + 1,
        e.name || ' ← ' || ep.path_to_root
    FROM employees e
    JOIN employee_path ep ON e.id = ep.manager_id
)
SELECT 
    level,
    name,
    path_to_root
FROM employee_path
ORDER BY level DESC;
```

---

## Работа с графами и сетями

### Пример: Социальная сеть (друзья друзей)
```sql
CREATE TABLE friendships (
    user1 TEXT,
    user2 TEXT
);

INSERT INTO friendships VALUES
('Алиса', 'Боб'),
('Боб', 'Чарли'),
('Чарли', 'Дэвид'),
('Алиса', 'Ева'),
('Ева', 'Фрэнк');

-- Находим всех друзей на расстоянии до 3 шагов от Алисы
WITH RECURSIVE friend_network AS (
    -- Базовый случай: сама Алиса
    SELECT 
        'Алиса' AS person,
        'Алиса' AS friend,
        0 AS distance,
        'Алиса' AS path
    
    UNION ALL
    
    -- Рекурсивный случай: друзья друзей
    SELECT 
        fn.person,
        f.user2,
        fn.distance + 1,
        fn.path || ' → ' || f.user2
    FROM friend_network fn
    JOIN friendships f ON fn.friend = f.user1
    WHERE fn.distance < 3
      AND f.user2 NOT IN (
          SELECT unnest(string_to_array(fn.path, ' → '))
      )  -- избегаем циклов
)
SELECT DISTINCT
    friend,
    distance,
    path
FROM friend_network
WHERE distance > 0
ORDER BY distance, friend;
```

---

## Практические применения

### Генерация календаря
```sql
WITH RECURSIVE calendar AS (
    -- Базовый случай: начальная дата
    SELECT DATE '2024-01-01' AS date
    
    UNION ALL
    
    -- Рекурсивный случай: следующий день
    SELECT date + INTERVAL '1 day'
    FROM calendar
    WHERE date < DATE '2024-01-31'
)
SELECT 
    date,
    EXTRACT(DOW FROM date) AS day_of_week,
    TO_CHAR(date, 'Day') AS day_name,
    CASE 
        WHEN EXTRACT(DOW FROM date) IN (0, 6) THEN 'Выходной'
        ELSE 'Рабочий день'
    END AS day_type
FROM calendar
ORDER BY date;
```

### Разложение числа на простые множители
```sql
WITH RECURSIVE prime_factors AS (
    -- Базовый случай: начинаем с числа и делителя 2
    SELECT 
        60 AS original_number,
        60 AS remaining,
        2 AS divisor,
        ARRAY[]::INTEGER[] AS factors
    
    UNION ALL
    
    -- Рекурсивный случай: находим множители
    SELECT 
        original_number,
        CASE 
            WHEN remaining % divisor = 0 THEN remaining / divisor
            ELSE remaining
        END,
        CASE 
            WHEN remaining % divisor = 0 THEN divisor
            ELSE divisor + 1
        END,
        CASE 
            WHEN remaining % divisor = 0 THEN factors || divisor
            ELSE factors
        END
    FROM prime_factors
    WHERE remaining > 1 AND divisor * divisor <= remaining
)
SELECT 
    original_number,
    factors || remaining AS all_factors,
    array_to_string(factors || remaining, ' × ') AS factorization
FROM prime_factors
WHERE remaining <= divisor OR remaining = 1
ORDER BY array_length(factors || remaining, 1) DESC
LIMIT 1;
```

---

## Оптимизация и ограничения

### Предотвращение бесконечной рекурсии
```sql
-- Установка лимита глубины рекурсии
SET max_stack_depth = '2MB';

-- Использование счетчика итераций
WITH RECURSIVE safe_recursion AS (
    SELECT 1 AS n, 0 AS iteration_count
    
    UNION ALL
    
    SELECT 
        n * 2, 
        iteration_count + 1
    FROM safe_recursion
    WHERE iteration_count < 20  -- максимум 20 итераций
)
SELECT * FROM safe_recursion;
```

### Оптимизация производительности
```sql
-- Создание индексов для иерархических запросов
CREATE INDEX idx_employees_manager ON employees(manager_id);
CREATE INDEX idx_friendships_user1 ON friendships(user1);

-- Использование MATERIALIZED VIEW для часто используемых иерархий
CREATE MATERIALIZED VIEW employee_hierarchy AS
WITH RECURSIVE hierarchy AS (
    SELECT id, name, manager_id, 0 as level, ARRAY[id] as path
    FROM employees WHERE manager_id IS NULL
    
    UNION ALL
    
    SELECT e.id, e.name, e.manager_id, h.level + 1, h.path || e.id
    FROM employees e
    JOIN hierarchy h ON e.manager_id = h.id
)
SELECT * FROM hierarchy;
```

---

## Полезные функции для рекурсии

### Функция для вычисления факториала
```sql
CREATE OR REPLACE FUNCTION factorial_recursive(n INTEGER)
RETURNS BIGINT AS $$
WITH RECURSIVE fact AS (
    SELECT 1 AS i, 1::BIGINT AS result
    UNION ALL
    SELECT i + 1, result * (i + 1)
    FROM fact
    WHERE i < n
)
SELECT result FROM fact WHERE i = n;
$$ LANGUAGE SQL;

-- Использование
SELECT factorial_recursive(10);  -- 3628800
```

### Функция для поиска пути в иерархии
```sql
CREATE OR REPLACE FUNCTION get_employee_path(emp_id INTEGER)
RETURNS TEXT AS $$
WITH RECURSIVE path AS (
    SELECT id, name, manager_id, name AS full_path
    FROM employees WHERE id = emp_id
    
    UNION ALL
    
    SELECT e.id, e.name, e.manager_id, e.name || ' ← ' || p.full_path
    FROM employees e
    JOIN path p ON e.id = p.manager_id
)
SELECT full_path FROM path WHERE manager_id IS NULL;
$$ LANGUAGE SQL;

-- Использование
SELECT get_employee_path(6);  -- Путь от продавца до директора
```

---

## Заключение

Рекурсивные запросы в PostgreSQL — мощный инструмент для:

- **Математических вычислений** (факториалы, Фибоначчи, степени)
- **Иерархических структур** (организации, категории, меню)
- **Графов и сетей** (социальные связи, маршруты)
- **Временных рядов** (календари, последовательности дат)

**Ключевые принципы:**
1. Всегда определяйте базовый случай
2. Используйте условие остановки
3. Избегайте бесконечной рекурсии
4. Оптимизируйте с помощью индексов
5. Рассмотрите материализованные представления для сложных иерархий