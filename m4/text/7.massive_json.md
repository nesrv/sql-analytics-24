# Составные типы данных в PostgreSQL

## Введение

PostgreSQL поддерживает мощные составные типы данных, которые позволяют хранить сложные структуры в одном поле. Рассмотрим три основных типа: массивы, перечисления и JSON.

---

## Массивы (Arrays)

### Создание и базовые операции

```sql
-- Создание таблицы с массивами
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT,
    tags TEXT[],                    -- массив строк
    prices NUMERIC[],               -- массив чисел
    ratings INTEGER[3],             -- массив фиксированной длины
    features TEXT[][]               -- двумерный массив
);

-- Вставка данных
INSERT INTO products (name, tags, prices, ratings, features) VALUES
('Смартфон', 
 ARRAY['электроника', 'мобильный', 'android'], 
 ARRAY[25000, 23000, 27000],
 ARRAY[5, 4, 5],
 ARRAY[['экран', '6.1 дюйма'], ['память', '128 ГБ']]
),
('Ноутбук',
 '{"компьютер","работа","игры"}',  -- альтернативный синтаксис
 ARRAY[45000.50, 42000.00],
 ARRAY[4, 5, 4],
 ARRAY[['процессор', 'Intel i5'], ['RAM', '16 ГБ'], ['SSD', '512 ГБ']]
);
```

### Доступ к элементам массива

```sql
-- Получение элементов по индексу (индексы начинаются с 1!)
SELECT 
    name,
    tags[1] AS first_tag,           -- первый элемент
    tags[2:3] AS middle_tags,       -- срез массива
    prices[1] AS min_price,
    features[1][2] AS screen_size   -- двумерный массив
FROM products;
```

**Результат:**
```
name      | first_tag   | middle_tags        | min_price | screen_size
----------|-------------|-------------------|-----------|-------------
Смартфон  | электроника | {мобильный,android} | 25000     | 6.1 дюйма
Ноутбук   | компьютер   | {работа,игры}      | 45000.5   | Intel i5
```

### Функции для работы с массивами

```sql
-- Основные функции
SELECT 
    name,
    array_length(tags, 1) AS tags_count,           -- длина массива
    array_upper(prices, 1) AS max_price_index,     -- верхний индекс
    array_lower(ratings, 1) AS min_rating_index,   -- нижний индекс
    cardinality(tags) AS total_tags                -- общее количество элементов
FROM products;

-- Проверка содержимого
SELECT name
FROM products
WHERE 'android' = ANY(tags);                      -- содержит элемент

SELECT name  
FROM products
WHERE tags @> ARRAY['электроника'];               -- содержит подмассив

SELECT name
FROM products  
WHERE tags && ARRAY['игры', 'работа'];            -- пересекается с массивом
```

### Модификация массивов

```sql
-- Добавление элементов
UPDATE products 
SET tags = array_append(tags, 'новинка')          -- добавить в конец
WHERE name = 'Смартфон';

UPDATE products
SET tags = array_prepend('топ', tags)             -- добавить в начало
WHERE name = 'Ноутбук';

-- Объединение массивов
UPDATE products
SET prices = prices || ARRAY[30000]               -- конкатенация
WHERE name = 'Смартфон';

-- Удаление элементов
UPDATE products
SET tags = array_remove(tags, 'android')          -- удалить элемент
WHERE name = 'Смартфон';
```

### Развертывание массивов

```sql
-- Превращение массива в строки
SELECT 
    name,
    unnest(tags) AS individual_tag
FROM products;

-- С номерами позиций
SELECT 
    name,
    tag_position,
    tag_value
FROM products,
     unnest(tags) WITH ORDINALITY AS t(tag_value, tag_position);

-- Агрегация обратно в массив
SELECT 
    array_agg(name ORDER BY name) AS all_products,
    array_agg(DISTINCT unnest(tags)) AS all_unique_tags
FROM products;
```

---

## Перечисления (ENUM)

### Создание и использование ENUM

```sql
-- Создание типа перечисления
CREATE TYPE product_status AS ENUM (
    'draft',        -- черновик
    'active',       -- активный
    'discontinued', -- снят с производства
    'archived'      -- архивный
);

CREATE TYPE priority_level AS ENUM ('low', 'medium', 'high', 'critical');

-- Создание таблицы с ENUM
CREATE TABLE inventory (
    id SERIAL PRIMARY KEY,
    product_name TEXT,
    status product_status DEFAULT 'draft',
    priority priority_level DEFAULT 'medium',
    quantity INTEGER
);

-- Вставка данных
INSERT INTO inventory (product_name, status, priority, quantity) VALUES
('iPhone 15', 'active', 'high', 50),
('iPhone 12', 'discontinued', 'low', 5),
('Samsung Galaxy', 'active', 'medium', 30),
('Nokia 3310', 'archived', 'low', 0);
```

### Работа с ENUM

```sql
-- Сортировка по порядку определения ENUM
SELECT product_name, status, priority
FROM inventory
ORDER BY status, priority;  -- сортировка по порядку в ENUM

-- Сравнение значений ENUM
SELECT product_name, priority
FROM inventory
WHERE priority >= 'medium';  -- medium, high, critical

-- Получение всех возможных значений
SELECT enumlabel 
FROM pg_enum 
WHERE enumtypid = 'product_status'::regtype
ORDER BY enumsortorder;

-- Приведение к строке и обратно
SELECT 
    product_name,
    status::TEXT AS status_text,
    'high'::priority_level AS high_priority
FROM inventory;
```

### Модификация ENUM

```sql
-- Добавление нового значения
ALTER TYPE product_status ADD VALUE 'pending' BEFORE 'active';
ALTER TYPE priority_level ADD VALUE 'urgent' AFTER 'high';

-- Переименование значения (PostgreSQL 10+)
ALTER TYPE product_status RENAME VALUE 'draft' TO 'new';

-- Удаление ENUM (только если не используется)
-- DROP TYPE product_status;
```

---

## JSON и JSONB

### Основы работы с JSON

```sql
-- Создание таблицы с JSON
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT,
    profile JSON,           -- JSON (текстовое хранение)
    settings JSONB,         -- JSONB (бинарное хранение, рекомендуется)
    created_at TIMESTAMP DEFAULT NOW()
);

-- Вставка JSON данных
INSERT INTO users (name, profile, settings) VALUES
('Алексей', 
 '{"age": 30, "city": "Москва", "hobbies": ["программирование", "чтение"]}',
 '{"theme": "dark", "notifications": {"email": true, "sms": false}, "language": "ru"}'
),
('Мария',
 '{"age": 25, "city": "СПб", "hobbies": ["спорт", "музыка", "путешествия"]}',
 '{"theme": "light", "notifications": {"email": false, "sms": true}, "language": "en"}'
);
```

### Извлечение данных из JSON

```sql
-- Операторы доступа
SELECT 
    name,
    profile->>'age' AS age,                    -- текстовое значение
    profile->'city' AS city_json,              -- JSON значение
    (profile->>'age')::INTEGER AS age_number,  -- приведение типа
    profile->'hobbies'->0 AS first_hobby       -- элемент массива
FROM users;

-- Путь к вложенным объектам
SELECT 
    name,
    settings->'notifications'->>'email' AS email_notifications,
    settings#>>'{notifications,sms}' AS sms_notifications  -- альтернативный синтаксис
FROM users;

-- Проверка существования ключей
SELECT name
FROM users
WHERE profile ? 'age'                          -- есть ключ 'age'
  AND settings->'notifications' ? 'email';     -- есть вложенный ключ
```

### Поиск и фильтрация JSON

```sql
-- Поиск по значениям
SELECT name
FROM users
WHERE profile->>'city' = 'Москва';

SELECT name  
FROM users
WHERE (profile->>'age')::INTEGER > 25;

-- Поиск в массивах JSON
SELECT name
FROM users
WHERE profile->'hobbies' ? 'программирование';  -- содержит элемент

SELECT name
FROM users  
WHERE profile->'hobbies' @> '["спорт"]';        -- содержит подмассив

-- Поиск по пути
SELECT name
FROM users
WHERE settings @> '{"theme": "dark"}';          -- содержит объект

SELECT name
FROM users
WHERE settings @@ '$.notifications.email == true';  -- JSONPath (PostgreSQL 12+)
```

### Модификация JSON

```sql
-- Обновление значений
UPDATE users
SET settings = jsonb_set(settings, '{theme}', '"auto"')
WHERE name = 'Алексей';

-- Добавление новых ключей
UPDATE users  
SET profile = profile || '{"phone": "+7-123-456-7890"}'
WHERE name = 'Мария';

-- Удаление ключей
UPDATE users
SET settings = settings - 'language'           -- удалить ключ
WHERE name = 'Алексей';

UPDATE users
SET settings = settings #- '{notifications,sms}'  -- удалить по пути
WHERE name = 'Мария';

-- Обновление массивов
UPDATE users
SET profile = jsonb_set(
    profile, 
    '{hobbies}', 
    (profile->'hobbies') || '["фотография"]'
)
WHERE name = 'Алексей';
```

### JSON функции и операторы

```sql
-- Извлечение ключей и значений
SELECT 
    name,
    jsonb_object_keys(settings) AS setting_keys
FROM users;

SELECT 
    name,
    key,
    value
FROM users,
     jsonb_each_text(profile) AS kv(key, value);

-- Агрегация JSON
SELECT 
    jsonb_agg(profile) AS all_profiles,
    jsonb_object_agg(name, settings) AS user_settings
FROM users;

-- Построение JSON из данных
SELECT 
    json_build_object(
        'user_name', name,
        'age', profile->>'age',
        'city', profile->>'city'
    ) AS user_summary
FROM users;

-- Валидация JSON
SELECT 
    name,
    profile,
    profile::jsonb IS NOT NULL AS is_valid_json
FROM users;
```

---

## Практические примеры

### Пример 1: Система тегов с массивами

```sql
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    title TEXT,
    tags TEXT[],
    view_counts INTEGER[]  -- просмотры по дням
);

INSERT INTO articles VALUES
(1, 'Изучаем PostgreSQL', ARRAY['база данных', 'SQL', 'обучение'], ARRAY[100, 150, 200]),
(2, 'Веб-разработка', ARRAY['HTML', 'CSS', 'JavaScript'], ARRAY[80, 120, 90]);

-- Поиск статей по тегам
SELECT title
FROM articles  
WHERE tags && ARRAY['SQL', 'JavaScript'];  -- пересечение тегов

-- Статистика по тегам
SELECT 
    unnest(tags) AS tag,
    COUNT(*) AS usage_count
FROM articles
GROUP BY tag
ORDER BY usage_count DESC;

-- Анализ просмотров
SELECT 
    title,
    array_length(view_counts, 1) AS days_tracked,
    view_counts[1] AS first_day_views,
    view_counts[array_upper(view_counts, 1)] AS last_day_views,
    (SELECT SUM(x) FROM unnest(view_counts) AS x) AS total_views
FROM articles;
```

### Пример 2: Система статусов с ENUM

```sql
CREATE TYPE order_status AS ENUM (
    'pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled'
);

CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    customer_name TEXT,
    status order_status DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT NOW()
);

-- Отчет по статусам
SELECT 
    status,
    COUNT(*) AS order_count,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (), 2) AS percentage
FROM orders
GROUP BY status
ORDER BY status;

-- Заказы в процессе (между confirmed и shipped)
SELECT customer_name, status
FROM orders
WHERE status BETWEEN 'confirmed' AND 'shipped';
```

### Пример 3: Конфигурация приложения с JSON

```sql
CREATE TABLE app_configs (
    id SERIAL PRIMARY KEY,
    app_name TEXT,
    config JSONB,
    version INTEGER DEFAULT 1
);

INSERT INTO app_configs (app_name, config) VALUES
('mobile_app', '{
    "features": {
        "push_notifications": true,
        "dark_theme": true,
        "offline_mode": false
    },
    "limits": {
        "max_file_size": 10485760,
        "api_calls_per_hour": 1000
    },
    "ui": {
        "language": "ru",
        "currency": "RUB"
    }
}');

-- Получение конфигурации
SELECT 
    app_name,
    config->'features'->>'push_notifications' AS push_enabled,
    config->'limits'->>'max_file_size' AS max_file_size,
    config#>>'{ui,language}' AS app_language
FROM app_configs;

-- Обновление конфигурации
UPDATE app_configs
SET config = jsonb_set(
    config, 
    '{features,offline_mode}', 
    'true'
), version = version + 1
WHERE app_name = 'mobile_app';
```

---

## Индексы для составных типов

### Индексы для массивов

```sql
-- GIN индекс для поиска в массивах
CREATE INDEX idx_products_tags ON products USING GIN (tags);

-- Поиск будет быстрым
SELECT name FROM products WHERE tags @> ARRAY['электроника'];
```

### Индексы для JSON

```sql
-- GIN индекс для JSONB
CREATE INDEX idx_users_settings ON users USING GIN (settings);

-- Частичный индекс для конкретных путей
CREATE INDEX idx_users_theme ON users ((settings->>'theme'));

-- Поиск будет оптимизирован
SELECT name FROM users WHERE settings @> '{"theme": "dark"}';
SELECT name FROM users WHERE settings->>'theme' = 'light';
```

---

## Лучшие практики

### Выбор между JSON и JSONB
- **JSON**: точное хранение текста, быстрая вставка
- **JSONB**: бинарное хранение, быстрые запросы, поддержка индексов

### Рекомендации по массивам
- Используйте для списков связанных значений
- Избегайте очень больших массивов (>1000 элементов)
- Создавайте GIN индексы для поиска

### Рекомендации по ENUM
- Планируйте значения заранее
- Используйте осмысленные имена
- Помните о порядке сортировки

### Рекомендации по JSON
- Валидируйте структуру на уровне приложения
- Используйте JSONB для частых запросов
- Создавайте индексы для часто используемых путей

---

## Заключение

Составные типы данных PostgreSQL предоставляют мощные возможности:

- **Массивы** — для хранения списков однотипных данных
- **ENUM** — для ограниченного набора значений с порядком
- **JSON/JSONB** — для гибких схем и сложных структур

Правильное использование этих типов может значительно упростить структуру базы данных и повысить производительность запросов.