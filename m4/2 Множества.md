# Объединение множеств. UNION

Оператор UNION позволяет объединить два множества (условно две таблицы). Но в отличие от inner/outer join объединения соединяют не столбцы разных таблиц, а два однотипных набора в один. Формальный синтаксис объединения:

```sql
SELECT_выражение1
UNION [ALL] SELECT_выражение2
[UNION [ALL] SELECT_выражениеN]
```

Например, пусть в базе данных будут две отдельные таблицы для клиентов банка (таблица `Customers`) и для сотрудников банка (таблица `Employees`):

```sql
CREATE TABLE Customers
(
    Id SERIAL PRIMARY KEY,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL,
    AccountSum NUMERIC DEFAULT 0
);
CREATE TABLE Employees
(
    Id SERIAL PRIMARY KEY,
    FirstName VARCHAR(20) NOT NULL,
    LastName VARCHAR(20) NOT NULL
);
  
INSERT INTO Customers(FirstName, LastName, AccountSum) VALUES
('Ольга', 'Александровна', 2000),
('Дарья', 'Павловна', 3000),
('Мария', 'Александровна', 4200),
('Наталья', 'Михайловна', 2800),
('Николай', 'Евгеньевич', 2500),
('Игорь', 'Михайлович', 2800);
  
INSERT INTO Employees(FirstName, LastName) VALUES
('Ольга', 'Александровна'),
('Дарья', 'Павловна'),
('Надежда', 'Юрьевна'),
('Николай', 'Евгеньевич'),
('Елена', 'Вячеславовна');

```

Здесь мы можем заметить, что обе таблицы, несмотря на наличие различных данных, могут характеризоваться двумя общими атрибутами - именем `FirstName` и фамилией `LastName`.

### Задание 19. Выберите сразу всех клиентов банка и его сотрудников из обеих таблиц:

```sql
SELECT FirstName, LastName FROM Customers
UNION SELECT FirstName, LastName FROM Employees;

```

![alt text](img/image-26.png)

В данном случае из первой таблицы выбираются два значения - `имя` и `фамилия` клиента. 

Из второй таблицы `Employees` также выбираются два значения - `имя` и `фамилия` сотрудников. 

То есть при объединении количество выбираемых столбцов и их тип совпадают для обеих выборок.


Если оба объединяемых набора содержат в строках идентичные значения, то при объединении повторяющиеся строки удаляются. 

В случае с таблицами `Customers` и `Employees` сотрудники банка могут быть одновременно его клиентами и содержаться в обеих таблицах. 

При объединении в примерах выше всех дублирующиеся строки удалялись. 

Например, исходя из начальных данных, мы видим, что три человека: `Ольга Александровна`, `Дарья Павловна`, `Николай Евгеньевич` располагаются в обеих таблицах. 

Однако при объединении дубли не считаются, поэтому `один` человек учитывается только `один` раз.

### Задание 1. Сохраните при объединении все, в том числе повторяющиеся строки с помощью оператора ALL:

```sql
SELECT FirstName, LastName
FROM Customers
UNION ALL SELECT FirstName, LastName 
FROM Employees;
```

![alt text](img/image-27.png)


При этом названия столбцов объединенной выборки будут совпадать с названия столбцов первой выборки. 

### Задание 2.  Произведите сортировку по FullName (FirstName + LastName)

```sql
SELECT FirstName || ' ' || LastName AS FullName
FROM Customers
UNION SELECT FirstName || ' ' || LastName AS EmployeeName 
FROM Employees
ORDER BY FullName;

```

![alt text](img/image-28.png)

 в выражениях `ORDER BY` необходимо ориентироваться именно на названия столбцов первой выборки

В данном случае каждая выборка имеет по одному столбцу, который представляет объединение имени и фамилии клиента или сотрудника. 

Для объединения строк применяется оператор ||. 

Но в случае с клиентами столбец будет называться `FullName`, а в случае с сотрудниками - `EmployeeName`. 

Тем не менее для сортировки применяется название столбца из первой выборки и он же будет в результирующей выборке:


Если же в одной выборке больше столбцов, чем в другой, то они не смогут быть объединены. Например, в следующем случае объединение завершится с ошибкой:

```sql
SELECT FirstName, LastName, AccountSum
FROM Customers
UNION SELECT FirstName, LastName 
FROM Employees;

```

Также соответствующие столбцы должны соответствовать по типу. 

Так, следующий пример завершится с ошибкой из-за не соответствия по типу данных:

```sql
SELECT FirstName, LastName
FROM Customers
UNION SELECT Id, LastName 
FROM Employees;

```


Здесь первый столбец первой выборки имеет тип `CHARACTER VARYING`, то есть хранит строку. 

Первый столбец второй выборки - `Id` имеет тип `INTEGER`, то есть хранит число.

Объединять выборки можно и из одной и той же таблицы. 

### Задание 3. В зависимости от суммы на счете клиента начислите ему определенные проценты:


```sql
SELECT FirstName, LastName, AccountSum + AccountSum * 0.1 AS TotalSum 
FROM Customers WHERE AccountSum < 3000
UNION SELECT FirstName, LastName, AccountSum + AccountSum * 0.3 AS TotalSum 
FROM Customers WHERE AccountSum >= 3000

```

В данном случае если сумма меньше 3000, то начисляются проценты в размере 10% от суммы на счете. 
Если на счете больше 3000, то проценты увеличиваются до 30%.

* 10 %  для AccountSum < 3000
* 30 %  для AccountSum >= 3000

![alt text](img/image-29.png)


# Разность множеств. EXCEPT

Оператор `EXCEPT` в `PostgreSQL` позволяет найти разность двух выборок, то есть те строки которые есть в первой выборке, но которых нет во второй. 

Для его использования применяется следующий формальный синтаксис:

```sql
SELECT_выражение1
EXCEPT SELECT_выражение2

```

Для примера возьмем предыдущие таблицы:


Таблица `Employees` содержит данные обо всех сотрудниках банка, а таблица `Customers` - обо всех клиентах.

Но сотрудники банка могут также быть его клиентами. 

### Задание 4. Найти всех клиентов банка, которые не являются его сотрудниками:

```sql
SELECT FirstName, LastName
FROM Customers
EXCEPT SELECT FirstName, LastName 
FROM Employees;

```
![alt text](img/image-30.png)


### Задание 5. Получить всех сотрудников банка, которые не являются его клиентами:

```sql
SELECT FirstName, LastName
FROM Employees
EXCEPT SELECT FirstName, LastName 
FROM Customers;
```

![alt text](img/image-31.png)


# Пересечение множеств. INTERSECT

Оператор `INTERSECT` позволяет найти общие строки для двух выборок, то есть данный оператор выполняет операцию пересечения множеств.

Для его использования применяется следующий формальный синтаксис:

```sql
SELECT_выражение1
INTERSECT SELECT_выражение2

```
### Задание 6. Найди всех сотрудников банка, которые одновременно являются его клиентами.


```sql
SELECT FirstName, LastName
FROM Employees
INTERSECT SELECT FirstName, LastName 
FROM Customers;
```
![alt text](img/image-32.png)


## Доп

```sql


```